Dijkstra's Algorithm Project

This project implements Dijkstra's Shortest Path Algorithm in both C++ and Python. The C++ program calculates the shortest paths from a given source vertex and exports the results to CSV files. The Python program then visualizes the results and analyzes the time complexity of the algorithm.

C++ Implementation

Features
- Dijkstra's Algorithm: Finds the shortest path from a source vertex to all other vertices in a graph represented by an adjacency matrix.
- CSV Export: Saves the distances and the paths from the source vertex to all other vertices in two separate CSV files.
  - dijkstra_output.csv: Contains the vertex and the corresponding shortest distance from the source.
  - dijkstra_path.csv: Contains the shortest path from the source to each vertex.


Python Implementation

Features
- Visualization: Reads the CSV files generated by the C++ program and visualizes the shortest path distances using bar charts.
- Time Complexity Analysis: Simulates random graphs and analyzes the time complexity of Dijkstra's algorithm by measuring the execution time for varying graph sizes.

Functions
- visualize_dijkstra_output(): Reads the distance and path CSV files, visualizes the shortest distances using a bar chart, and prints the paths.
- generate_graph(V): Generates a random adjacency matrix for a graph with `V` vertices.
- dijkstra_time_complexity(V): Runs a dummy implementation of Dijkstra's algorithm on randomly generated graphs and records the execution time.
- plot_time_complexity(V, times): Plots the time complexity of Dijkstra's algorithm for graphs of increasing sizes.

Time Complexity Analysis
To analyze how the execution time scales with the number of vertices, the script runs Dijkstra's algorithm for graphs of increasing sizes and plots the time required for each graph size.

Requirements
- C++ compiler (for the C++ implementation)
- Python 3 and the following libraries:
  - pandas
  - matplotlib
  - numpy

Future Improvements
- Allow dynamic input of graph edges instead of requiring a full adjacency matrix.
- Implement optimizations like priority queues (e.g., using a min-heap) to improve Dijkstra's algorithm's efficiency.
- Extend the visualization with more interactive elements using tools like 'Plotly'.
